
//浮点数的家族包括；float double long double类型 
//浮点数表示的范围在头文件float.h中定义 

//浮点数在计算机内部的表示方法
/*
根据国际标准IEEE754，任意一个二进制浮点数v可以
表示成下面的形式；
 
1.（-1）^S * M * 2^E
2. (-1)^S 表示符号位，当s=0，v为正数；当s=1，v为负数
3. M 表示有效数字，大于等于1，小于2
4. 2^E 表示指数位(小数点移动的位数，向左为正，向右为负) 

举例来说；
十进制的5.0，写成二进制是101.0，相当于1.01x2^2
那么，按照上面v的格式，可以得出s=0，m=1.01，e=2
十进制的-5.0，写成二进制是-101.0， 相当于-1.01x2^2
那么，按照上面v的格式，可以得出s=1，m=1.01，e=2

IEEE 754规定；
对于32的浮点数，最高的一位是符号位s，接着的8位是指数e，
剩下的23位为有效数字m 
对于64位的浮点数，最高的一位是符号位s，接着的11位是指数e，
剩下的52位为有效数字m

IEEE 754对有效数字m和指数e，还有一些特别的规定
前面说过，m大于等于1小于2，也就是说，m可以写成1.xxxxxxxxx的形式
其中xxxxxxxxxx表示小数部分
IEEE 754规定，在计算机内部保存m时，默认这个数的第一位是1，只
保存后面xxxxxxxx的部分，读取时再把前面加上1，这样一来就可以节省
一位有效数字，以32为浮点数为例，留给m的只有23位，将第一位的1舍去以
后，等于可以保存24位有效数字(存储时舍去整数只保存小数部分，释放时再加上)

至于指数e，情况就比较复杂了
//指数e的存入 
首先，e为一个无符号整数，这意味着，如果e为8位，它的取值范围为0-255
如果e为11位，它的取值范围为0-2047.但是，我们知道，科学记数法中的
e是可以出现负数的，所以IEEE 754规定，存入内存时e的真实值必须再加上一个 
中间数，对于8位的e，这个中间数是127，对于11位的e，这个中间数是1023.
比如，2^10的e是10，所以保存成32位浮点数时，必须保存成10+127=137，即10001001
(e存入内存的时候加上中间值，8位加127，11位加1023)
 
//指数e的取出
指数e从内存中取出还可以分为三种情况；
1.e不全为0或不全为1 
这时，浮点数就采用下面的规则表示，即指数e的计算值减去127或1023，得到真实值
，再将有效数字m前加上第一位的1.比如；0.5的二进制形式为0.1，由于规定正数部分
必须为1，即将小数点右移一位，则为1.0*2^(-1)，其阶码为-1+127=126
表示为01111110，而尾数1.0去掉整数部分为0，补齐到23位则其二进制表现形式位
0 01111110 00000000000000000000000
(在e不全为1或0的情况下还原真实值减去127或1023后在前第一位加1)

2.e全为0
这时，浮点数的指数e等于1-127或1-1023即位真实值，有效数字m不再加上1，而是还原成
0.xxxxxxx的小数，这样做是为了表示±0，以及接近0的很小的数字
(指数恒定为1-127或1-1023，且不加1，整数部分为0 ，小数部分照旧) 

3.e全为1
这时，如果有数字m全为0，表示无穷大(正负取决于符号位s)
(暂且不做相应讨论) 
 
